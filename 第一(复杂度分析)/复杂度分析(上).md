如何分析、统计算法的执行效率和资源消耗，有两种方法：一种是==事后分析法==（直接跑代码）；另一种是==大O表示法==


### 为什么要进行复杂度的分析，不直接跑代码（事后分析法）？

- 测试结果非常依赖测试环境： 比如硬件环境


- 测试结果受数据规模影响很大： 对同一个排序算法，测试数据的有序度不同，排序算法的执行时间会有很大的区别
    



### 大O时间复杂度表示法(10：17)

##### 什么是大O时间复杂度表示法：[^5]
	
[^5]: 时间复杂度的比较仅限于功能相同的代码之间如果两段代码功能都相同，比较时间复杂度就没有意义了

1. 只表示数据规模n很大时候的执行效率[^3]
2. 忽略低价、常量、系数，只保留最高量级
3. ==表示执行时间与随数据规模之间的关系，而不是具体的执行时间==

[^3]: 只表示N规模很大的原因
				
				数据大了，才需要使用比较好的算法；数据比较少，就不需要啥算法，所以需要研究代码的执行时间，随数据规模增长的变化趋势


##### 跟事后分析法的==区别==

不用具体的测试数据，可以粗略的估计算法的执行效率

##### 大O的推导过程

1. T(n) = (2n^2+2n+3) * unit_time;

       unit_time：每个语句的执行时间 
       T(n)：  所有代码的执行时间


2. T(n) = O(f(n))

    f(n)=2n^2+2n+3:  每行代码的执行次数总和
    n: 数据的规模
	
    **O: T(n)的执行时间与f(n)成正比**
    

##### 时间复杂度分析方法

1. 只看循环次数最多的一段代码 

2. 加法法则[^1]

	 [^1]: 大O时间复杂度的加法法则(从书里去查)

		总的时间复杂度就等于量级最大的那段代码
		T1(n)=O(f(n))
		T2(n)=O(g(n))
		T(n)=T1(n)+T2(n)=max(O(f(n)),O(g(n))) =O(max(f(n), g(n))).

3. 乘法法则[^2]

	[^2]: 乘法法则
					 
		循环嵌套代码的复杂度等于嵌套内外代码复杂度的乘积
		T(n) = T1(n) * T2(n) = O(n*n) = O(n2)

##### 代码的复杂度由两个数据的规模来决定

1. 加法法则

	T1(m) + T2(n) = O(f(m) + g(n))	

2. 乘法法则


#### 几种常见的时间复杂度(24:07)

##### 多项式量级(常用)

下面的几种常见时间复杂度的量级逐步增大。

###### O(1) 常量阶[^常量阶]
[^常量阶]: 代码的执行时间不随n的增大而增长


###### O($log n$) 对数阶 [^4]
  
  [^4]:   推论$\log_3 n$ 与$\log_2 n$的复杂的是一样的

###### O(n) 线性阶
###### O(n $log n$)   线性对数阶
###### O($n^2$)   平方阶
###### O($n^3$)  立方阶
###### O($n^k$)   k方阶

##### 非多项式量级(不讨论)

非多项式量级算法的执行时间会急剧增加，求解问题的执行时
间会无限增长。所以，==非多项式时间复杂度的算法其实是非常低效的算法==
所以就==不讨论==了么


###### O($2^n$) 指数阶

######  O(n!) 阶乘阶


##### 上面代码的实例

```javascript

	// 对数阶例子

	let i=1;
	while(i<n){
		i=i*2;
	}


```



### 空间复杂度

表示算法的存储空间与数据规模之间的增长关系

常见的空间复杂度： O(1) O(n) O($n^2$)





