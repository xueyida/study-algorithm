### 为什么要用最好时间复杂度、最坏情况下的时间复杂度、平均情况时间复杂度？

在长度为n的数组中查找一个变量X，有三种情况：

1. x在第一位(复杂度O(1))
2. 数组中没有x(复杂度O(n))

### 分析时间复杂度，包括平时说的时间负责度的时候主要用哪一种？
大多数情况下不用区分
同一段代码在不同的情况下，时间复杂度有量级的差距时，才会用三种复杂度来区分

### 最好情况时间复杂度


### 最坏情况复杂度


### 平均情况复杂度

例子：在长度为n的数组中，查找变量X

（1+2+3+...+n+n）/ (n+1)


平均时间复杂度：

1. 第一种情况， 所有的情况遍历的元素次数累加，除以N（好像用的是第二种，因为这一种）

2. 第二种情况，加权平均时间复杂度（每种情况出现的概率*每种情况的遍历次数 的累加）

两种情况的计算方式，但是好像使用第二种的情况比较多
    


### 均摊时间复杂度与均摊分析

#### 例子：
往一个数组中插入数据，当数组满了之后，用for循环遍历数组之和，并把sum放入到数组的第一个位置；如果数组一开始就有空闲，则直接插入数组


最好情况时间复杂度： O(1)
最坏情况时间复杂度： O(n)
平均情况复杂度： 使用第二种情况么


#### 为什么需要均摊时间复杂度？
上述例子中的平均时间复杂度并不需要这么复杂，不需要引入概率论的知识；

1. 复杂度大多数情况下为O(1),极端情况下为O(n)
2. O(n)与O(1)出现的频率非常规律——一个O(n)之后插入n-1个O(1)


针对这种情况，使用平均复杂度比较复杂

如何均摊？
把O(n)的那次操作，均摊到接下来的n-1次操作中

O(1+n/(n-1))


#### 均摊时间复杂度总结

1. 对一个数据结构数据进行一组连续操作，大部分情况时间复杂度都很低，个别情况时间复杂度比较高

2. 这些操作之间存在前后连贯的时序关系

3. 放到一块（这里作者的表述不是很到位）

4. 将较高时间复杂度，平摊到时间复杂度比较低的操作

5. 一般均摊时间复杂度，旧等于最好情况时间复杂度












