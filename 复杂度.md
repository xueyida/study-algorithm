## 复杂度分析

    如何分析、统计算法的执行效率和资源消耗

### 为什么要进行复杂度的分析，不直接跑代码（事后分析法）？

- 测试结果非常依赖测试环境

    硬件环境、


- 测试结果受数据规模影响很大

    对同一个排序算法，测试数据的有序度不同，排序算法的执行时间会有很大的区别
    

- 总之直接执行，受各种影响，不好分析



### 大O复杂度表示法


跟事后分析法的区别：

- 不用具体的测试数据，可以粗略的估计算法的执行效率


大O的推导过程：

1. T(n) = (2n^2+2n+3) * unit_time;

       unit_time：每个语句的执行时间 
       T(n)：  所有代码的执行时间



2. T(n) = O(f(n))

        f(n)=2n^2+2n+3:  每行代码的执行次数总和
        n: 数据的规模
        O: T(n)的执行时间与f(n)成正比
    


### 大O时间复杂度

**不是**表示代码真正的执行时间，**而是**表示**代码的执行时间**随**数据规模**增长的**变化趋势**【需要多留意，理解】

数据大了，才需要使用比较好的算法；数据比较少，就不需要啥算法，所以需要研究代码的执行时间，随数据规模增长的变化趋势


#### 时间复杂度分析方法

1. 只看循环次数最多的一段代码 

2. 加法法则: 量级最大的那段代码

    跟1有点相似

    T(n) = 100+n+n^2 时间复杂度为n^2



3. 乘法法则: 循环嵌套代码的复杂度等于嵌套内外代码复杂度的乘积


#### 几种常见的时间复杂度

##### 多项式量级

- O(1) 常量阶

    代码的执行时间不随n的增大而增长

- O($ log n$) 对数阶

    实例代码：

    ```javascript
        let i=1;
        while(i<n){
            i=i*2;
        }
    
    ```

    推论：

    1.  $2^x$=n

    2. x=$log_2 n$


    emmm不知道用啥标题：

    $\log_3 n$ 与$\log_2 n$的复杂的式一样的，推论之后再说（需要用公式推算一哈）    

- O(n) 线性阶
- O(n $ log n $)  ------    线性对数阶
- O($ n^2 $)  ----------    平方阶
- O($ n^3 $)  ----------    立方阶
- O($ n^k $)  ----------     k方阶

##### 非多项式量级

非多项式量级算法的执行时间会急剧增加，求解问题的执行时
间会无限增长。所以，非多项式时间复杂度的算法其实是非常低效的算法
所以就不讨论了么


- O($2^n$) 指数阶

- O(n!) 阶乘阶


### 空间复杂度






