实例代码展示

```javascript
	
	// 其他分析的例子
	function search(a:[], n, target){
		for(let i=0;i<n;i++){
			if(a[i] === target){
				return i;
			}
		}
		return -1;
	}	

```

```javascript

	/**
		均摊分析的例子
		
		往一个数组中插入数据，当数组满了之后，用for循环遍历数组之和，并把sum放入到数组的第一个位置；如果数组一开始就有空闲，则直接插入数组

	**/
	let arr = new Array[n];
	let count = 0;

    function insert(val){
		if (count == array.length) {

			int sum = 0;
		
			for (int i = 0; i < array.length; ++i) {
			
				sum = sum + array[i];
			
			}
		
			array[0] = sum;
			
				count = 1;
			
			}
		
			array[count] = val;
		
			++count;		
	}


```
### 最坏、最好、平均时间复杂度

##### 为什么要用最好时间复杂度、最坏情况下的时间复杂度、平均情况时间复杂度？

为了表示代码在不同情况下的不同时间复杂度，所以引入了三个概念;
*以开头的例子为例，查找的变量x可能出现在任意位置；正好在第一个元素出现，时间复杂度为==O(1)==,如果数组中不存在变量x，那么就需要把整个数组遍历一遍，时间复杂度为==O(n)==*


##### 平时说的分析时间复杂度主要用哪一种？
指的是所有的时间复杂度，都需要分析一下，==大多数情况下不用区分，同一段代码在不同的情况下，时间复杂度有量级的差距时，才会用三种复杂度来区分==

##### 最好情况时间复杂度

在最理想的情况下，执行这段代码的时间复杂度


##### 最坏情况复杂度

在最糟糕的情况下，执行这段代码的时间复杂度


##### 平均情况复杂度[^1]
在平均的情况下，执行这段代码的时间复杂度
	

[^1]: 为什么要使用平均复杂度

			最好情况时间复杂度和最坏情况时间复杂度对应的都是极端情况下的代码复杂度，发生的概率其实并不大；
			为了更好地表示平均情况下的复杂度，我们引入另一个概念：平均时间复杂度。


###### 如何分析平均情况时间复杂度
1. 第一种情况， 所有的情况遍历的元素次数累加，除以N（好像用的是第二种，因为这一种）
![[平均.png]]

2. 第二种情况，加权平均时间复杂度（每种情况出现的概率*每种情况的遍历次数 的累加）
![[加权平均.png]]

##### 均摊时间复杂度[^2]

对于均摊时间复杂度，我们使用==均还分析==的方法进行分析；是一种特殊的平均时间复杂度


[^2]: 为什么需要均还时间复杂度

				上述例子中的平均时间复杂度并不需要这么复杂，不需要引入概率论的知识；
				针对这种情况，使用平均复杂度比较复杂 	


###### 什么情况下使用均摊时间复杂度

1. 对一个数据结构数据进行一组连续操作，大部分情况时间复杂度都很低，个别情况时间复杂度比较高

2. 这些操作之间存在前后连贯的时序关系，并且有一定的规律



##### 摊还分析[^3]

1. 将较高时间复杂度，平摊到时间复杂度比较低的操作

2. 一般均摊时间复杂度，就等于最好情况时间复杂度



[^3]: 对均摊时间复杂度的分析，叫摊还分析












